import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

function json(data: any, status = 200) {
  return NextResponse.json(data, { status });
}
function bad(message: string, status = 400) {
  return json({ error: message }, status);
}

// Classic Elo helpers
function expectedScore(rA: number, rB: number) {
  return 1 / (1 + Math.pow(10, (rB - rA) / 400));
}
function updateElo(ra: number, rb: number, scoreA: 0 | 1, K: number) {
  const ea = expectedScore(ra, rb);
  const deltaA = K * (scoreA - ea);
  const newA = Math.round(ra + deltaA);
  const newB = Math.round(rb - deltaA);
  return { newA, newB, deltaA: Math.round(newA - ra), deltaB: Math.round(newB - rb) };
}

export async function POST(req: Request) {
  // Admin guard
  const hdrName = process.env.API_AUTH_HEADER ?? "x-admin-key";
  const expected = process.env.API_AUTH_TOKEN ?? "";
  if (expected) {
    const provided = req.headers.get(hdrName) ?? "";
    if (provided !== expected) return bad("unauthorized", 401);
  }

  let body: any;
  try { body = await req.json(); } catch { return bad("invalid json"); }

  let { p1, p2, loserScore, openedBy = "discord:unknown", channelId = "discord", winner } = body ?? {};
  if (!p1 || !p2 || (loserScore === undefined || loserScore === null)) return bad("missing p1, p2, loserScore");
  if (typeof p1 !== "string" || typeof p2 !== "string") return bad("p1 and p2 must be strings");

  p1 = String(p1).trim(); p2 = String(p2).trim();
  if (!p1 || !p2 || p1.toLowerCase() === p2.toLowerCase()) return bad("invalid players (empty or same)");

  const ls = Math.max(0, Math.min(9, Math.floor(Number(loserScore))));
  const winTag: "p1" | "p2" = (String(winner ?? "p1").toLowerCase() === "p2") ? "p2" : "p1";
  const now = new Date();
  const K = Number(process.env.ELO_K ?? 32);

  const [u1, u2] = await Promise.all([
    prisma.user.findFirst({ where: { username: { equals: p1, mode: "insensitive" } } }),
    prisma.user.findFirst({ where: { username: { equals: p2, mode: "insensitive" } } }),
  ]);
  if (!u1 || !u2) {
    const missing = [!u1 ? p1 : null, !u2 ? p2 : null].filter(Boolean).join(", ");
    return bad(`unknown user(s): ${missing}`, 404);
  }

  const aIsWinner = (winTag === "p1");
  const Ra = u1.elo ?? 1200;
  const Rb = u2.elo ?? 1200;

  let newA: number, newB: number, dA: number, dB: number;
  if (aIsWinner) {
    const r = updateElo(Ra, Rb, 1, K); newA = r.newA; newB = r.newB; dA = r.deltaA; dB = r.deltaB;
  } else {
    const r = updateElo(Rb, Ra, 1, K);
    newB = r.newB; newA = r.newA;
    dB = Math.round(newB - Rb);
    dA = Math.round(newA - Ra);
  }

  const winnerUser = aIsWinner ? u1 : u2;
  const loserUser  = aIsWinner ? u2 : u1;

  // Try to settle an OPEN match for this channel/pair first (any order)
  const open = await prisma.match.findFirst({
    where: {
      channelId,
      state: "OPEN",
      OR: [
        { p1UserId: winnerUser.id, p2UserId: loserUser.id },
        { p1UserId: loserUser.id,  p2UserId: winnerUser.id },
      ],
    },
    orderBy: { openedAt: "desc" },
  });

  const tx = await prisma.$transaction(async (px) => {
    const match = open
      ? await px.match.update({
          where: { id: open.id },
          data: { state: "SETTLED", loserScore: ls, winnerUserId: winnerUser.id, settledAt: now },
        })
      : await px.match.create({
          data: {
            channelId,
            p1UserId: winnerUser.id,
            p2UserId: loserUser.id,
            state: "SETTLED",
            loserScore: ls,
            winnerUserId: winnerUser.id,
            openedBy,
            openedAt: now,
            settledAt: now,
          },
        });

    // Update users
    await px.user.update({
      where: { id: winnerUser.id },
      data: { elo: aIsWinner ? newA : newB, wins: (winnerUser.wins ?? 0) + 1 },
    });
    await px.user.update({
      where: { id: loserUser.id },
      data: { elo: aIsWinner ? newB : newA, losses: (loserUser.losses ?? 0) + 1 },
    });

    // Persist Elo deltas for reversal
    await px.matchEloDelta.createMany({
      data: [
        {
          matchId: match.id,
          userId: winnerUser.id,
          before: aIsWinner ? Ra : Rb,
          after:  aIsWinner ? newA : newB,
          delta:  aIsWinner ? dA  : dB,
          createdAt: now,
        },
        {
          matchId: match.id,
          userId: loserUser.id,
          before: aIsWinner ? Rb : Ra,
          after:  aIsWinner ? newB : newA,
          delta:  aIsWinner ? dB  : dA,
          createdAt: now,
        },
      ],
    });

    return match;
  });

  return json({
    ok: true,
    recordedAt: now.toISOString(),
    matchId: tx.id,
    channelId,
    winner: winnerUser.username,
    loser: loserUser.username,
    loserScore: ls,
    elo: {
      [u1.username]: { before: Ra, after: newA, delta: dA },
      [u2.username]: { before: Rb, after: newB, delta: dB },
    },
  });
}
